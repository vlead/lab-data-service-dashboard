#+TITLE: The REST API for Lab Data Service Dashboard
#+AUTHOR: VLEAD
#+DATE: [2017-06-05 Mon]
#+SETUPFILE: ../../org-templates/level-2.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction 
  This document illustrates building of the REST API.

* REST
** Serve index.html
#+NAME: serve_index_html
#+BEGIN_SRC python 
@api.route("/", methods=['GET'])
def index():
	return render_template('index.html')

#+END_SRC

** Login API
   API to login to the application.
*** API Design
  - URL :: /login
  - Method :: GET
  - Success Response ::
    + Code: 200
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/login
    #+END_EXAMPLE
  - Error Response ::
    + Code: 400 - Google OAuth error
    + Code: 401 - HTTP error
*** =Login API=
    When user clicks on =login= button from f/e it will invoke =/login= api and
    thereby it will forward request to =google=. User must sign in using it's 
    google credentials which is then stored in our database.
#+NAME: oauth_session_creation
#+BEGIN_SRC python 
def get_google_auth(state=None, token=None):
    if token:
        return OAuth2Session(Auth.CLIENT_ID, token=token)
    if state:
        return OAuth2Session(
            Auth.CLIENT_ID,
            state=state,
            redirect_uri=Auth.REDIRECT_URI)
    oauth = OAuth2Session(
        Auth.CLIENT_ID,
        redirect_uri=Auth.REDIRECT_URI,
        scope=Auth.SCOPE)
    return oauth

#+END_SRC


#+NAME: login_route
#+BEGIN_SRC python
@api.route('/login', methods=["GET"])
def login():
    if current_user.is_authenticated:
        return redirect("/")
    google = get_google_auth()
    auth_url, state = google.authorization_url(
        Auth.AUTH_URI, access_type='offline')
    session['oauth_state'] = state
    return redirect(auth_url, code=302)
 
#+END_SRC
    
*** Google Callback response =API=
    - Once the Google verfies the user credentials it will send callback
      response to =/authorized= api which should be registered at google's
      dashboard as one of Authorized redirect URIs

    - Once google authenticates the user, =userdirectory= application will
      authorize the user to use the application.

#+NAME: callback_google_api
#+BEGIN_SRC python
@api.route('/gCallback')
def callback():
    if current_user is not None and current_user.is_authenticated:
        return redirect("/")
    if 'error' in request.args:
        if request.args.get('error') == 'access_denied':
            current_app.logger.error("You have been denied access.")
            return 'You have been denied access.'
        return 'Error encountered.'
    if 'code' not in request.args and 'state' not in request.args:
        return redirect("/")
    else:
        google = get_google_auth(state=session.get('oauth_state'))
        try:
            token = google.fetch_token(
                Auth.TOKEN_URI,
                client_secret=Auth.CLIENT_SECRET,
                authorization_response=request.url)
        except:
            return jsonify(success=False, message="HTTP connectivity error"), 401

        google = get_google_auth(token=token)
        resp = google.get(Auth.USER_INFO)
        data = resp.json()
        if resp.status_code == 200:
            email = data['email']
            current_app.logger.debug("Email = %s" % email)
            user = User.query.filter_by(email=email).first()
            current_app.logger.debug("User = %s" % user)
            if user is None:
                return render_template("index.html")
            roles = Roles.query.all()
            allroles = []
            for i in roles:
                temp = i.to_dict()
                allroles.append(temp['role'])
            if user.role in allroles:
                current_app.logger.debug("cheking user role in all roles")
                login_user(user)
                current_app.logger.debug("User Logged in Sucessfully")
                session['type'] = user.role
            else:
                return render_template("index.html")

            session['google_token'] = token
            session['data'] = user.to_dict()
            current_app.logger.debug("data = %s" % session['data'])
#            print session['data']
            return redirect('/')

        return  jsonify(success=False, message="Couldn't fetch information"), 400

#+END_SRC

*** Google OAuth Credentials
    Google OAuth service required URLs (Credentials) should be specified

#+NAME: google_oauth_configuration
#+BEGIN_SRC python

class Auth:
    CLIENT_ID = "Your client ID"
    CLIENT_SECRET = "Your client secret"
    REDIRECT_URI = 'https://localhost:5000/gCallback'
    AUTH_URI = 'https://accounts.google.com/o/oauth2/auth'
    TOKEN_URI = 'https://accounts.google.com/o/oauth2/token'
    USER_INFO = 'https://www.googleapis.com/userinfo/v2/me'
    SCOPE = ['https://www.googleapis.com/auth/userinfo.profile', 'https://www.googleapis.com/auth/userinfo.email']

#+END_SRC
 
** Logout API
   When user clicks on =logout= button from front end dashboard it will invoke
   =/logout= api and thereby it will destroy all session variables.

*** API Design

  - URL :: /logout
  - Method :: GET
  - URL Params ::  None
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400 - No user in session
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/logout
    #+END_EXAMPLE

*** Implementation

#+NAME: logout_route
#+BEGIN_SRC python

@api.route('/logout', methods=["GET"])
@login_required
def logout():
    if session.get('_id') is not None:
        try:
            logout_user()
            current_app.logger.debug("User Logged out Sucessfully")
            session.clear()
            return redirect("/")
        except:
            return jsonify(success=False, message="No session present"), 400

    else:
        return redirect("/")

#+END_SRC
** Logged In
 API to return current session state.
*** API Design
   - URL :: /logged_in
   - Method :: GET
   - Success Response ::
    + Code: 200
   - Error Response ::
    + Code: 400 
*** Implemenation
#+NAME: logged_in
#+BEGIN_SRC python
@api.route('/logged_in', methods=['GET'])
def loggedin():
    if 'google_token' in session:
        current_app.logger.debug("Google Token is available in session")
        return jsonify(success=True, session=session['data']), 200
    else:
        current_app.logger.error("Failed to locate Google Token in session")
        return jsonify(success=False), 300

#+END_SRC
** Add User
   API to add a User
*** API Design
  - URL :: /add_user
  - Method :: POST
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - URL params ::
    {
      "name":"test",
      "email":"test@gmail.com"
      "role" : "admin"
    }
  - Example ::
    #+BEGIN_EXAMPLE
     http://localhost:5000/add_user
    #+END_EXAMPLE

*** Implementation
    Only Admin has the right to add a user and assign role to him. To add a
user =Name= , =Email= and =Role= fields are required.  Implementation of the
=Add User API= is given below.

#+NAME: add_user
#+BEGIN_SRC python 
@api.route('/add_user', methods=['POST'])
@login_required
@requires_admin_auth
def create_user():
    try:
        temp = json.loads(request.data)
        email = temp['email']
        name = temp['name']
        role = temp['role']
    except:
        try:
            email = request.args.get('email')
            name = request.args.get('name')
            role = request.args.get('role')
        except KeyError as e:
            current_app.logger.error("%s not sent in the request"
                                         "to add a User" %e.args)
            return jsonify(success=False, message="%s not sent"
                               "in the request" % e.args), 400

    if not (name or email or role):
        current_app.logger.error("Arguments are not provided to add a User")
        return jsonify(success=False, message="Arguments not provided"), 400

    try:
        match = re.match(r"(^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$)"\
                             , email)
        if match is None:
            current_app.logger.error("Email is not valid to add a User")
            return jsonify(success=False, message="Please enter"
                               "a valid email"), 400         
    except:
        current_app.logger.error("Some arguments were missing to add a User")
        return jsonify(success=False, message="Arguments went missing"), 400

    check_role = Roles.query.filter(Roles.role_name==role).first()
    if check_role is None:
        current_app.logger.error("Role does not exist to add a User")
        return jsonify(success=False, message="Role doesn't exist"), 400

    u = User()
    u.name = name
    u.email = email
    u.role = role
    current_app.logger.debug("Adding user with name = %s, email = %s,"
    " role=%s" %(u.name, u.email, u.role))
    db.session.add(u)
    try:
        db.session.commit()
        current_app.logger.debug("Sucessfully Added user with name = %s," 
                                     "email = %s, role=%s"\
                                     %(u.name, u.email, u.role))

    except IntegrityError as e:
        db.session.rollback()
        current_app.logger.error("Email already exists. Failed to add a new"
                                     "User with same email Id")
        return jsonify(success=False, message="This email already exists"), 500

    return jsonify(success=True)

#+END_SRC

*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_add_user.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session,\
     jsonify    
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Add User

#+NAME: test_add_user
#+BEGIN_SRC python :tangle app/tests/test_add_user.py
class TestAddUser(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()


    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_add_user_1(self):
		print "test_add_user_1"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), 
                                        headers=headers)
		payload = {
                    'name': 'Test1',
		            'email': 'test1@gmail.com',
		            'role': 'admin'
		          }
		headers = {'Content-Type': 'application/json'}

		response = self.client.post("/add_user", data=json.dumps(payload), 
                                        headers=headers)

		self.assertEqual(response.status_code, 200)

    def test_add_user_2(self):
        print "test_add_user_2"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
    
        payload = {
                    'name': 'Test2',
                    'email': 'te@st2@gmailcom',
                    'role': 'admin'
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload),
                                        headers=headers)

        self.assertEqual(response.status_code, 400)

    def test_add_user_3(self):
        print "test_add_user_3"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
    
        payload = {
                    'email': 'test3@gmail.com',
                    'role': 'admin'
                  }
        headers = {'Content-Type': 'application/json'}
        #data=json.dumps(payload)
        #temp = json.loads(data)
        #email = temp['email']
        #print email

        response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

        self.assertEqual(response.status_code, 400)

    def test_add_user_4(self):
        print "test_add_user_4"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
    
        payload = {
                    'name': 'Test4',
                    'email': 'test4@gmail.com',
                    'role': 'developer'
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

        self.assertEqual(response.status_code, 400)

    def test_add_user_5(self):
        print "test_add_user_5"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
    
        payload = {
                    'name': 'Test5',
                    'role': 'admin'
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

        self.assertEqual(response.status_code, 400)

    def test_add_user_6(self):
        print "test_add_user_6"
        payload = {'name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
    
        payload = {
                    'name': 'Test6',
                    'email': 'test6@gmail.com',
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

        self.assertEqual(response.status_code, 400)

    def test_add_user_7(self):
        print "test_add_user_7"
        payload = {'name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
    
        payload = {
                    'name': 'Test7',
                    'email': 'test7@gmail.com',
                    'role': ''
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

        self.assertEqual(response.status_code, 400)
#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_add_user.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Add Role
   API to add a role
*** API Design
 - URL :: /add_role
  - Method :: POST
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - URL Params ::
    {
      "role_name":"admin"
    }
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/add_role
    #+END_EXAMPLE
*** Implementation
    Admin has the right to add a role thus restricting the access to the LDS
servive.To add a role =role_name= field should be given.  Implementation of the
=Add Role= API is given below.
#+NAME: add_role
#+BEGIN_SRC python 
@api.route('/add_role', methods=['POST'])
@login_required
@requires_admin_auth
def create_role():
    try:
        temp = json.loads(request.data)
        name = temp['role_name']
    except:
        try:
            name = request.args['role_name']
            current_app.logger.debug("creating new role with role_name=%s"
                                         % name)
        except KeyError as e:
            current_app.logger.error("%s not sent in the request"
                                         % e.args)

            return jsonify(success=False, message="%s not sent in the request"
                               % e.args), 400

    if not name:
        current_app.logger.error("No role provided")
        return jsonify(success=False, message="No role provided"), 400

    u = Roles(role_name=name)
    db.session.add(u)
    current_app.logger.debug("Adding new role..")
    try:
        db.session.commit()
        current_app.logger.debug("Sucessfully added new role..")
    except IntegrityError as e:
        db.session.rollback()
        current_app.logger.error("This role already exists")
        return jsonify(success=False, message="This role already exists"), 500
	
    return jsonify(success=True)

#+END_SRC
*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_add_role.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, \
     jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Add Role
#+NAME: test_add_role
#+BEGIN_SRC python :tangle app/tests/test_add_role.py
class TestAddRole(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_add_role_1(self):
        print "test_add_role_1"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
        
        self.assertEqual(response.status_code, 200)
    def test_add_role_2(self):
        print "test_add_role_2"
        payload = {'role_name': ''}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
        
        self.assertEqual(response.status_code, 400)   

    def test_add_role_3(self):
        print "test_add_role_3"
        payload = {'role_name': None}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
        
        self.assertEqual(response.status_code, 400)
#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_add_role.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Show users
   API for show users
*** API Design
 - URL :: /users
  - Method :: GET
  - URL Params ::  None
  - Success Response ::
    + Code: 200
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/users
    #+END_EXAMPLE

*** Implementation
    This API shows the list of all users who are registered for the LDS.  The
    implementation is given below.

#+NAME: show_users
#+BEGIN_SRC python 
@api.route('/users', methods=['GET'])
@login_required
@disable_access_on_hash
def show_users():
    current_app.logger.debug("running show users...")
    users = User.query.all()
    allusers = []
    for u in users:
        temp = u.to_dict()
        allusers.append(temp)
    return jsonify(success=True,users=allusers)

#+END_SRC
*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_show_users.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, \
     jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Show users
#+NAME: test_show_users
#+BEGIN_SRC python :tangle app/tests/test_show_users.py
class TestShowUsers(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()
		
    def test_show_user_1(self):
        print "test_show_user_1"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
		
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
		
        payload = {'name': 'Test1',
			       'email': 'test1@gmail.com',
		           'role' : 'admin'
		           }
        headers = {'Content-Type': 'application/json'}
		
        response = self.client.post("/add_user", data=json.dumps(payload),
                                        headers=headers)

        response = self.client.get("/users", headers=headers)
		
        self.assertEqual(response.status_code, 200)

    def test_show_user_2(self):
        print "test_show_user_2"
        payload = {'name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload),
                                        headers=headers)
    
        payload = {
                    'name': 'Test2',
                    'email': 'test2@gmail.com',
                    'role': ''
                  }
        headers = {'Content-Type': 'application/json'}

        response = self.client.post("/add_user", data=json.dumps(payload),
                                        headers=headers)

        response = self.client.get("/users", headers=headers)
        self.assertEqual(response.status_code, 200)

    def test_show_user_3(self):
        print "test_show_user_3"
        response = self.client.get("/users")
        self.assertEqual(response.status_code, 200)

#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_show_users.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Show roles
*** API Design
 - URL :: /roles
  - Method :: GET
  - URL Params ::  None
  - Success Response ::
    + Code: 200
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/roles
    #+END_EXAMPLE
	      
*** Implementation
This API returns the list of all the roles in the LDS.
Implementation of =show role= API is given below
#+NAME: show_roles
#+BEGIN_SRC python
@api.route('/roles', methods=['GET'])
@login_required
@disable_access_on_hash	
def show_roles():
    current_app.logger.debug("running show roles...")
    roles = Roles.query.all()
    allroles = []
    for r in roles:
        temp = r.to_dict()
        allroles.append(temp)
    return jsonify(success=True,roles=allroles)

#+END_SRC

*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_show_roles.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client


#+end_src
**** Test Show Roles
#+NAME: test_show_roles
#+BEGIN_SRC python :tangle app/tests/test_show_roles.py
class TestShowRole(TestCase):
	TESTING = True
	def create_app(self):
		app = Flask(__name__)
		app.register_blueprint(api, url_prefix=None)
		app.config.from_object("runtime.config.flask_app_config")
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
                app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
                app.config['DATABASE_CONNECT_OPTIONS'] = {}
		login_manager = LoginManager(app)
		login_manager.login_view = "users.login"
		self.app = app.test_client()
		db.init_app(app)
		return app

	def setUp(self):
                app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
		db.create_all()

	def test_show_roles_1(self):
		print "test_show_roles_1"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
		
		response = self.client.get("/roles", headers=headers)
		
		self.assertEqual(response.status_code, 200)

	def test_show_roles_2(self):
		print "test_show_roles_2"
		payload = {'role_name': ''}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
		
		response = self.client.get("/roles", headers=headers)
		
		self.assertEqual(response.status_code, 200)	

	def test_show_roles_3(self):
		print "test_show_roles_3"
		
		response = self.client.get("/roles")
		
		self.assertEqual(response.status_code, 200)
#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_show_roles.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Delete User
   API for Delete User
*** API Design
  - URL :: /delete_user
  - Method :: DELETE
  - URL Params ::  
       None
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/delete_user?email=test@gmail.com
    #+END_EXAMPLE
*** Implementation
    Admin also has the right to delete a user. To delete a user =email= should
    be given as the field to delete a particular user.

#+NAME: delete_user
#+BEGIN_SRC python 
@api.route('/delete_user', methods=['POST'])
@login_required
@requires_admin_auth
def delete_user():
    try:
        temp = json.loads(request.data)
        email = temp['user_email']
    except:
        try:
            email = request.args['user_email']
            current_app.logger.debug("deleting user with email=%s" % email)
        except KeyError as e:
            current_app.logger.error("%s not sent in the request" % e.args)
            return jsonify(success=False, message="%s not sent in the"
                               "request" % e.args), 400

    user = User.query.filter(User.email == email)
    user_todel = user.first()
    
    if user_todel is None:
        current_app.logger.error("This email does not exists to delete user")
        return jsonify(success=False,
                           message="This email does not exists"), 400
    elif (user_todel == current_user):
        current_app.logger.error("This is not a valid operation")
    	return jsonify(success=False,
                           message="This is not a valid operation"), 400
    elif (user_todel.role == 'admin' and len(user) == 1):
        current_app.logger.error("At least one admin must be present")
    	return jsonify(success=False,
                           message="At least one admin must be present"), 400

    db.session.delete(user_todel)
    current_app.logger.debug("Deleting user %s" % user_todel)
    try:
        db.session.commit()
        current_app.logger.debug("Successfully deleted user %s" % user_todel)
    except IntegrityError as e:
        db.session.rollback()
        current_app.logger.error("could'nt delete the user %s" % user_todel)
        return jsonify(success=False, message="could'nt delete the user"), 500
    return jsonify(success=True)

#+END_SRC
*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_delete_user.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Delete user
#+NAME: test_delete_user
#+BEGIN_SRC python :tangle app/tests/test_delete_user.py
class TestDeleteUser(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_delete_user_1(self):
		print "test_delete_user_1"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
        
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
        
		payload = {'name': 'Test1.1',
			       'email': 'test1.1@gmail.com',
		           'role' : 'admin'
		           }
		
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

		response = self.client.post("/delete_user?user_email=test1@gmail.com", headers=headers)
		
		self.assertEqual(response.status_code, 400)

    def test_delete_user_2(self):
		print "test_delete_user_2"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
        
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
        
		payload = {'name': 'Test2',
			       'email': 'test2@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

		response = self.client.post("/delete_user?user_email=", headers=headers)
		
		self.assertEqual(response.status_code, 400)

    def test_delete_user_3(self):
		print "test_delete_user_3"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
		payload = {'name': 'Test3',
			       'email': 'test3@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)

		response = self.client.post("/delete_user?user_email=test@gmail.com", headers=headers)
		
		self.assertEqual(response.status_code, 400)	
	

#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_delete_user.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Delete Role
   API to Delete a Role
*** API Design
 - URL :: /delete_role
  - Method :: POST
  - URL Params ::  
       None
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/delete_role?role_name=admin
    #+END_EXAMPLE
*** Implementation
    Admin has the right to delete a role. To delete a role, =role_name= 
    should be sent as an argument.
    Implementation of =delete role= is given below.
#+NAME: delete_role
#+BEGIN_SRC python
@api.route('/delete_role', methods=['POST'])
@login_required
@requires_admin_auth	
def delete_role():
    try:
        temp = json.loads(request.data)
        role_name = temp['role_name']
    except:
        try:
            role_name = request.args['role_name']
            current_app.logger.debug("deleting role with role_name=%s"
                                         % role_name)
        except KeyError as e:
            current_app.logger.error("%s not sent in the request"
                                         % e.args)
            return jsonify(success=False, message="%s not sent in the request"
                               % e.args), 400

    if not role_name:
        current_app.logger.error("No role provided")
        return jsonify(success=False, message="No role provided"), 400

    role_todel = Roles.query.filter(Roles.role_name==role_name).first()
    
    if role_todel is None:
        current_app.logger.error("This role does not exists")        
        return jsonify(success=False, message="This role does not exists"), 400
    elif (role_todel == 'admin'):
        current_app.logger.error("You cannot delete this role")                
    	return jsonify(success=False, message="You cannot delete"
                           "this role"),400
    
    current_app.logger.debug("Deleting role %s" %role_todel)                
    db.session.delete(role_todel)

    try:
        current_app.logger.debug("Deleted role %s" %role_todel)                
        db.session.commit()
    except IntegrityError as e:
        db.session.rollback()
        current_app.logger.error("could'nt delete the role" %role_todel)                
        return jsonify(success=False, message="could'nt delete the role"), 500
    return jsonify(success=True)

#+END_SRC

*** Test Cases
**** Imports
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_delete_role.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, jsonify       
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Delete role
#+NAME: test_delete_role
#+BEGIN_SRC python :tangle app/tests/test_delete_role.py
class TestDeleteRole(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()

    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_delete_user_1(self):
        print "test_delete_role_1"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
        
        response = self.client.post("/delete_role?role_name=admin", headers=headers)

        self.assertEqual(response.status_code, 200)

    def test_delete_user_2(self):
		print "test_delete_role_2"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
		
		response = self.client.post("/delete_role?role_name=", headers=headers)

		self.assertEqual(response.status_code, 400)

    def test_delete_user_3(self):
        print "test_delete_role_3"
        payload = {'role_name': 'admin'}
        headers = {'Content-Type': 'application/json'}
        
        response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)
        
        response = self.client.post("/delete_role?role_name=guest", headers=headers)

        self.assertEqual(response.status_code, 400)

#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_delete_role.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Update User
   API to Update a User
*** API Design
 - URL :: /update_user
  - Method :: PUT
  - URL Params ::  
    {
       "email" : "test@gmail.com"
       "new_email" : "test1@gmail.com"
       "new_role" : "admin"
       "new_name" : "test1"
    }
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/update_user?email=test@gmail.com
    #+END_EXAMPLE
*** Implementation
    Admin has the right to edit the details of a student who is registered 
    for the Lab Data Service. He can edit any of the details =name=,=email=
    or =role=.
    The implementation is given below.
#+NAME: update_user
#+BEGIN_SRC python
@api.route('/update_user', methods=['PUT'])
@login_required
@requires_admin_auth
def update_user():
    try:
        temp = json.loads(request.data)
        email = temp['email']
        new_name = temp['new_name']
        new_email = temp['new_email']
        new_role = temp['new_role']
    except:
        try:
            email = request.args.get['email']
            new_name = request.args.get['new_name']
            new_email = request.args.get['new_email']
            new_role = request.args.get['new_role']
        except KeyError as e:
            current_app.logger.error("%s not sent in the request" %e.args)                
            return jsonify(success=False, message="%s not sent in the request"
                               % e.args), 400

    if not (new_name or new_role or new_email):
        current_app.logger.error("Invalid arguments were provided")                        
        return jsonify(success=False, message="Invalid arguments were"
                           "provided"), 400

    user_toupdate = User.query.filter(User.email == email).first()
    user_checkupdate = User.query.filter(User.email == new_email).first()

    if user_toupdate is None:
        current_app.logger.error("This email doesn't exists")                        
        return jsonify(success=False, message="This email doesn't exists"), 400
    elif user_checkupdate is not None and user_checkupdate != user_toupdate:
        current_app.logger.error("Email is already registered in our"
        "database.")                        
        return jsonify(success=False, message="Email is already registered"
                           "in our database."), 400

    check_role = Roles.query.filter(Roles.role_name == new_role).first()
    if check_role is None:
        current_app.logger.error("%s Role doesn't exist" %check_role)
        return jsonify(success=False, message="Role doesn't exist"), 400
    elif check_role.role_name == 'admin' and check_role != current_user:
        current_app.logger.error("You cannot edit another admin")
        return jsonify(success=False, message="You cannot edit another admin"),
        400

    user_toupdate.name = new_name
    user_toupdate.email = new_email
    user_toupdate.role = new_role
    current_app.logger.debug("Updating User...")
    try:
        db.session.commit()
        current_app.logger.debug("Updated User Successfully...")
    except IntegrityError as e:
        session.rollback()
        current_app.logger.error("Could not update the user")
        return jsonify(success=False, message="Could not update the user"), 500

    return jsonify(success=True)

#+END_SRC

								:boilerplate:
*** Test Cases
**** Imports
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_update_user.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

#+end_src
**** Test Update user
#+NAME: test_update_user
#+BEGIN_SRC python :tangle app/tests/test_update_user.py
class TestUpdateUsers(TestCase):
	TESTING = True
	def create_app(self):
		app = Flask(__name__)
		app.register_blueprint(api, url_prefix=None)
		app.config.from_object("runtime.config.flask_app_config")
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
		app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
		app.config['DATABASE_CONNECT_OPTIONS'] = {}
		login_manager = LoginManager(app)
		login_manager.login_view = "users.login"
		self.app = app.test_client()
		db.init_app(app)
		return app

	def setUp(self):
		app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
		db.create_all()

	def tearDown(self):
		db.session.remove()
		db.drop_all()

	def test_update_user_1(self):
		print "test_update_user_1"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test1',
			       'email': 'test1@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': 'Test_1',
			       'email': 'test@gmail.com',
			       'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 400)

	def test_update_user_2(self):
		print "test_update_user_2"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test2',
			       'email': 'test2@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': '',
			       'email': 'test1@gmail.com',
				   'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 400)

	def test_update_user_3(self):
		print "test_update_user_3"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test3',
			       'email': 'test3@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': 'Test_3',
			       'email': 'test@gmail.com',
				   'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 400)
#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_update_user.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** Update Profile
   API to Update a User
*** API Design
 - URL :: /update_profile
  - Method :: PUT
  - URL Params ::  
    {
       "email" : "test@gmail.com"
       "new_email" : "test1@gmail.com"
       "new_role" : "admin"
       "new_name" : "test1"
    }
  - Success Response ::
    + Code: 200
  - Error Response ::
    + Code: 400
  - Example ::
    #+BEGIN_EXAMPLE
    http://localhost:5000/update_profile?email=test@gmail.com
    #+END_EXAMPLE
*** Implementation
    Admin has the right to edit the details of a student who is registered 
    for the Lab Data Service. He can edit any of the details =name=,=email=
    or =role=.
    The implementation is given below.
#+NAME: update_profile
#+BEGIN_SRC python

@api.route('/update_profile', methods=['PUT'])
@login_required
def update_own():
    try:
        temp = json.loads(request.data)
        email = temp['email']
        new_name = temp['new_name']
        new_email = temp['new_email']
    except:
        try:
            email = request.args.get['email']
            new_name = request.args.get['new_name']
            new_email = request.args.get['new_email']
        except KeyError as e:
            current_app.logger.error("%s not sent in the request" % e.args)
            return jsonify(success=False, message="%s not sent in the request"
                               % e.args), 400

    if email != session['data']['email']:
        current_app.logger.error("There was a session's email mismatch"
                                     % e.args)
        return jsonify(success=False, message="There was a session's"
                           "email mismatch"), 400
    elif not (new_name or new_email):
        current_app.logger.error("Invalid arguments were provided")
        return jsonify(success=False, message="Invalid arguments"
                           "were provided"), 400

    user_toupdate = User.query.filter(User.email == email).first()
    user_checkupdate = User.query.filter(User.email == new_email).first()

    if user_toupdate is None:
        current_app.logger.error("This email doesn't exists.")
        return jsonify(success=False, message="This email"
                           "doesn't exists."), 400
    elif user_checkupdate is not None and user_toupdate != user_checkupdate:
        current_app.logger.error("Email is already registered"
                                     "in our database.")
        return jsonify(success=False, message="Email is already"
                           "registered in our database."), 400

    user_toupdate.name = new_name
    user_toupdate.email = new_email
    current_app.logger.debug("Updating user...")
    try:
        db.session.commit()
        current_app.logger.debug("Updated user successfully")
    except IntegrityError as e:
        session.rollback()
        current_app.logger.error("Could not update the user")
        return jsonify(success=False, message="Could not update the user"), 500
    if user_toupdate.email == session['data']['email']:
        return jsonify(success=True, logout=True), 200
    else:
        return jsonify(success=True, logout=False), 200
#+END_SRC

								:boilerplate:

*** Test Cases
**** Imports 
#+name: imports_for_tests
#+BEGIN_SRC python :tangle app/tests/test_update_profile.py
# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session, jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

config = {
        'SQLALCHEMY_DATABASE_URI': 'sqlite:///' ,
        'DATABASE_CONNECT_OPTIONS': {},
        'SQLALCHEMY_TRACK_MODIFICATIONS': False,         
    }
#+end_src
**** Test Update Profile
#+NAME: test_update_profile
#+BEGIN_SRC python :tangle app/tests/test_update_profile.py
class TestUpdateUsers(TestCase):
	TESTING = True
	def create_app(self):
		app = Flask(__name__)
		app.register_blueprint(api, url_prefix=None)
		app.config.from_object("runtime.config.flask_app_config")
		app.config['TESTING'] = True
		app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
		app.config['LOGIN_DISABLED'] = True
		login_manager = LoginManager(app)
		login_manager.login_view = "users.login"
		self.app = app.test_client()
		db.init_app(app)
		return app

	def setUp(self):
		app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
		db.create_all()

	def tearDown(self):
		db.session.remove()
		db.drop_all()

	def test_update_user_1(self):
		print "test_update_user_1"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test1',
			       'email': 'test1@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': 'Test_1',
			       'email': 'test1@gmail.com',
				   'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 200)

	def test_update_user_2(self):
		print "test_update_user_2"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test2',
			       'email': 'test2@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': '',
			       'email': 'test1@gmail.com',
				   'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 400)

	def test_update_user_3(self):
		print "test_update_user_3"
		payload = {'role_name': 'admin'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'role_name': 'user'}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_role", data=json.dumps(payload), headers=headers)

		payload = {'name': 'Test3',
			       'email': 'test3@gmail.com',
		           'role' : 'admin'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/add_user", data=json.dumps(payload), headers=headers)
		
		payload1 = {'new_name': 'Test_3',
			       'email': 'test@gmail.com',
				   'new_email': 'test1@gmail.com',
		           'new_role' : 'user'
		           }
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.put("/update_user", data=json.dumps(payload1), headers=headers)

		self.assertEqual(response.status_code, 400)
#+END_SRC
**** Running tests
#+NAME: run_test_cases
#+BEGIN_SRC python :tangle app/tests/test_update_profile.py
if __name__ == '__main__':
    unittest.main()

#+END_SRC
** LDS Request APIs
*** Get Requests
**** API Design
   - URL :: /lds_auth_get
   - Method :: GET
   - Success Response ::
    + Code: 200
   - Error Response ::
    + Code: 400 
**** Implementation
     According to the design, the user interface sends a request to the LDS
     dashboard and then the dashboard internally sends a request to the actual
     LDS server.

     We get data from the user interface which contains =call=. It indicates
     which entity's data you want to access. A request is sent to LDS along
     with =call= and data is returned by LDS. Accordingly we display the data
     to the user.

#+NAME: lds_get
#+BEGIN_SRC python
@api.route('/lds_auth_get', methods=['GET'])
@login_required
def lds_connect1():
    try:
        payload = request.args.get('call')
    except:
        return jsonify(success=False, message="Arguments were broken"), 400

    try:
        http_proxy = os.environ['http_proxy']
        https_proxy = os.environ['https_proxy']
    except:
        http_proxy = https_proxy = ''
        os.environ['http_proxy'] = os.environ['https_proxy'] = ''

    os.environ['http_proxy'] = os.environ['https_proxy'] = ''
    r = requests.get('https://localhost:1307/'+payload, verify = False)
    os.environ['http_proxy'] = http_proxy
    os.environ['https_proxy'] = https_proxy
    return jsonify(success=True, data=r.json()), 200

#+END_SRC
**** Test Cases
#+NAME:
#+BEGIN_SRC python

# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request,\
     session, jsonify        
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

class TestLdsGet(TestCase):
	TESTING = True
	def create_app(self):
		app = Flask(__name__)
		app.register_blueprint(api, url_prefix=None)
		app.config.from_object("runtime.config.flask_app_config")
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
                app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
                app.config['DATABASE_CONNECT_OPTIONS'] = {}
		login_manager = LoginManager(app)
		login_manager.login_view = "users.login"
		self.app = app.test_client()
		db.init_app(app)
		return app

	def setUp(self):
		app.config['TESTING'] = True
		app.config['LOGIN_DISABLED'] = True
		db.create_all()

	def test_lds_get_1(self):
		print "test_lds_get_1"
		headers = {'Content-Type': 'application/json'}
		
		payload = {
					"path": "vlabs.ac.in/images/static/logo.png",
					"asset_type": "Image",
					"key": "defaultkey"
		}
		
		response = self.client.post("/http://10.2.58.182:5000/assets",
                                        data=json.dumps(payload),
                                        headers=headers)
		
		response = self.client.get("/lds_auth_get?call=assets",
                                       headers=headers)
		
		self.assertEqual(response.status_code, 200)


	def test_lds_get_2(self):
		print "test_lds_get_2"
		response = self.client.get("/lds_auth_get?call=asets")
		
		self.assertEqual(response.status_code, 404)

if __name__ == '__main__':
    unittest.main()
#+END_SRC
*** Post Requests
**** API Design
   - URL :: /lds_auth_post
   - Method :: POST
   - Success Response ::
    + Code: 200
   - Error Response ::
    + Code: 400 
**** Implementation
     As we have discussed earlier, user interface sends a request to LDS
     dashboard and then the dashboard sends a request to LDS. Instead of
     writing separate functions for each entity , we have written a generic
     function which can be used to send all types of POST requests.

     We get =data= and =call= from the user interface. =data= stores the input
     given by the user while adding an entity. While sending a request to LDS,
     we also send a key indicating the user is authorized.  =call= indicates
     the entity to be accessed so that it is added to the url and an
     appropriate request is sent to LDS.

#+NAME: lds_post
#+BEGIN_SRC python
@api.route('/lds_auth_post', methods=['POST'])
@login_required
def lds_connect2():
    try:
        payload = request.data
    except:
        try:
            payload = json.dumps(request.args)
             
        except:
            return jsonify(success=False, message="Arguments were broken"), 400

    payment = json.loads(payload)['data']
    print payment 
    payment['key'] = 'defaultkey'
    call = json.loads(payload)['call']+'s'
    data = json.dumps(payment)
    
    try:
        http_proxy = os.environ['http_proxy']
        https_proxy = os.environ['https_proxy']
    except:
        http_proxy = https_proxy = ''
        os.environ['http_proxy'] = os.environ['https_proxy'] = ''

    os.environ['http_proxy'] = os.environ['https_proxy'] = ''
    headers = {'content-type': 'application/json'}
    r = requests.post('https://localhost:1307/'+call,data=data,
                          verify = False,
                          headers=headers)
    os.environ['http_proxy'] = http_proxy
    os.environ['https_proxy'] = https_proxy

    return jsonify(success=True, message="Life is broken"), 200

#+END_SRC
**** Test Cases
#+NAME:
#+BEGIN_SRC python

# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session,\
     jsonify    
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

class TestLdsPost(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()


    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_lds_post_1(self):
		print "test_add_post_1"
		payload = {
			'call': 'assets',
			'data': {
				'path': 'vlabs.ac.in/images/static/logo.png',
				'asset_type': 'Image'
			}
		}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/lds_auth_post",
                                        data=json.dumps(payload),
                                        headers=headers)

		self.assertEqual(response.status_code, 200)


    def test_lds_post_2(self):
		print "test_add_post_2"
		payload = {
			'call': 'asset',
			'data': {
				'path': 'vlabs.ac.in/images/static/logo.png',
				'asset_type': 'Image'
			}
		}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/lds_auth_post",
                                        data=json.dumps(payload),
                                        headers=headers)

		self.assertEqual(response.status_code, 404)


    def test_lds_post_3(self):
		print "test_add_post_3"
		payload = {
			'call': 'assets',
			'data': {
				'asset_type': 'Image'
			}
		}
		headers = {'Content-Type': 'application/json'}
		
		response = self.client.post("/lds_auth_post",
                                        data=json.dumps(payload),
                                        headers=headers)

		self.assertEqual(response.status_code, 500)

if __name__ == '__main__':
    unittest.main()

#+END_SRC
*** Put Requests
**** API Design
   - URL :: /lds_auth_put
   - Method :: PUT
   - Success Response ::
    + Code: 200
   - Error Response ::
    + Code: 400 
**** Implementation
     As already been said in the previous slides, even for the PUT methods to
     update entities, we take input from the user and send the data to the LDS
     dashboard through an AJAX call.  Then the dashboard makes an AJAX request
     to LDS with the data.  It also adds a key to the data indicating that the
     user is authorized and the action can be performed.  The dashboard adds
     =call= to the url indicating which entity is being updated.

#+NAME: lds_put
#+BEGIN_SRC python
@api.route('/lds_auth_put', methods=['PUT'])
@login_required
def lds_connect3():
    try:
        payload = request.data
    except:
        try:
            payload = json.dumps(request.args)
        except:
            return jsonify(success=False, message="Arguments were broken"), 400
    
    payment = json.loads(payload)['data'] 
    payment['key'] = 'defaultkey'
    call = json.loads(payload)['call']+'s'
    data = json.dumps(payment)    

    try:
        http_proxy = os.environ['http_proxy']
        https_proxy = os.environ['https_proxy']
    except:
        http_proxy = https_proxy = ''
        os.environ['http_proxy'] = os.environ['https_proxy'] = ''

    os.environ['http_proxy'] = os.environ['https_proxy'] = ''
    headers = {'content-type': 'application/json'}
    r = requests.put('https://localhost:1307/'+call, data=data,
                         headers=headers, verify = False)
    os.environ['http_proxy'] = http_proxy
    os.environ['https_proxy'] = https_proxy

    return jsonify(success=True, message="Life is broken"), 200
#+END_SRC
**** Test Cases
#+NAME: test_logged_in
#+BEGIN_SRC python
@api.route('/logged_in', methods=['GET'])
def loggedin():
    if 'google_token' in session:
        current_app.logger.debug("Google Token is available in session")
        return jsonify(success=True, session=session['data']), 200
    else:
        current_app.logger.error("Failed to locate Google Token in session")
        return jsonify(success=False), 300
#+END_SRC
*** Delete Requests
**** API Design
   - URL :: /lds_auth_delete
   - Method :: DELETE
   - Success Response ::
    + Code: 200
   - Error Response ::
    + Code: 400 
**** Implementation
     Similar to GET, POST and PUT requests, even the DELETE request is dealt in
     the same way. When the user wants to delete some data of a particular
     entity, he sends a request to the LDS dashboard.  The dashboard then adds
     a key if the user is authorised and sends a request to LDS. It adds =call=
     to the url indicating which entity is to be accessed.

#+NAME: lds_delete
#+BEGIN_SRC python
@api.route('/lds_auth_delete', methods=['DELETE'])
@login_required
def lds_connect4():
    try:
        payload = request.data
    except:
        try:
            payload = json.dumps(request.args)
        except:
            return jsonify(success=False, message="Arguments were broken"), 400

    payment = json.loads(payload)['data']['id']
    key = 'key=defaultkey'
    call = json.loads(payload)['call']+'s'
    data = json.dumps(payment) 

    try:
        http_proxy = os.environ['http_proxy']
        https_proxy = os.environ['https_proxy']
    except:
        http_proxy = https_proxy = ''
        os.environ['http_proxy'] = os.environ['https_proxy'] = ''

    os.environ['http_proxy'] = ''
    os.environ['https_proxy'] = ''
    r = requests.delete('https://localhost:1307/'+call+'?'+payment+'&'+key,
                            verify = False)
    os.environ['http_proxy'] = http_proxy
    os.environ['https_proxy'] = https_proxy

    return jsonify(success=True, message="Life is broken"), 200
#+END_SRC
**** Test Cases
#+NAME: 
#+BEGIN_SRC python

# -*- coding: utf-8 -*-
import unittest
import os
import sys
from flask import Flask, Blueprint, json, render_template, request, session,\
     jsonify    
from flask_testing import TestCase
from flask_sqlalchemy import SQLAlchemy
from sqlalchemy.exc import IntegrityError
from runtime.rest.app.users.api import api
import datetime
from flask_login import LoginManager
from runtime.rest.app.users.db import User, Roles
import re

from runtime.rest.app import app, db
import client

class TestLdsPost(TestCase):
    TESTING = True
    def create_app(self):
        app = Flask(__name__)
        app.register_blueprint(api, url_prefix=None)
        app.config.from_object("runtime.config.flask_app_config")
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///'
        app.config['DATABASE_CONNECT_OPTIONS'] = {}
        login_manager = LoginManager(app)
        login_manager.login_view = "users.login"
        self.app = app.test_client()
        db.init_app(app)
        return app

    def setUp(self):
        app.config['TESTING'] = True
        app.config['LOGIN_DISABLED'] = True
        db.create_all()


    def tearDown(self):
        db.session.remove()
        db.drop_all()

    def test_lds_put_1(self):
		print "test_lds_put_1"
	
		headers = {'Content-Type': 'application/json'}
		payload = {
		       'path': 'vlabs.ac.in/images/static/logo.png',
			   'asset_type' : 'Image',
			   'key' : 'defaultkey'
		}

		response = self.client.post("/http://10.2.58.182:5000/assets",
                                        data=json.dumps(payload),
                                        headers=headers)
	
		payload = {
			'call': 'assets?path=vlabs.ac.in/images/static/logo.png',
			'data': {
				'asset_type': 'Video'
			}
		}
		
		response = self.client.put("/lds_auth_put",
                                       data=json.dumps(payload),
                                       headers=headers)

		self.assertEqual(response.status_code, 200)


    def test_lds_put_2(self):
		print "test_lds_put_2"

		headers = {'Content-Type': 'application/json'}
		payload = {
		       'path': 'vlabs.ac.in/images/static/logo.png',
			   'asset_type' : 'Image',
			   'key' : 'defaultkey'
		}

		response = self.client.post("/http://10.2.58.182:5000/assets",
                                        data=json.dumps(payload),
                                        headers=headers)
		
		payload = {
			'call': 'asset?path=vlabs.ac.in/images/static/logo.png',
			'data': {
				'asset_type': 'Video'
			}
		}
		
		response = self.client.put("/lds_auth_put",
                                       data=json.dumps(payload),
                                       headers=headers)

		self.assertEqual(response.status_code, 404)

    def test_lds_put_3(self):
		print "test_lds_put_3"
	
		headers = {'Content-Type': 'application/json'}
		payload = {
		       'path': 'vlabs.ac.in/images/static/logo.png',
			   'asset_type' : 'Image',
			   'key' : 'defaultkey'
		}

		response = self.client.post("/http://10.2.58.182:5000/assets",
                                        data=json.dumps(payload),
                                        headers=headers)
		
		payload = {
			'call': 'assets?path=vlabs.ac.in/images/static/logo.png',
			'data': {
				'asset': 'Video'
			}
		}
		
		response = self.client.put("/lds_auth_put", data=json.dumps(payload),
                                       headers=headers)

		self.assertEqual(response.status_code, 500)


if __name__ == '__main__':
    unittest.main()

#+END_SRC
* Infra                                                         :boilerplate:
** sources
*** Imports 
#+name: imports_for_sources
#+BEGIN_SRC python

# -*- coding: utf-8 -*-
from flask import Blueprint, Flask, url_for, redirect, \
    render_template, session, request, jsonify, current_app
from flask_sqlalchemy import SQLAlchemy
from flask_login import login_required, login_user, \
    logout_user, current_user
from requests_oauthlib import OAuth2Session
from requests.exceptions import HTTPError
from runtime.config.goauth_config import Auth
from runtime.rest.app import app, db, requires_guest_auth, \
     requires_admin_auth, disable_access_on_hash
from runtime.rest.app.users.db import User, Roles
import os
import json
import re
import time
from sqlalchemy.exc import IntegrityError

api = Blueprint('users', __name__)

#+end_src
    
    
*** Init File
#+NAME: init_file
#+BEGIN_SRC python :tangle app/users/__init__.py

#+END_SRC
* Tangle                                                        :boilerplate:  
** sources
#+BEGIN_SRC python :tangle app/users/api.py :eval no :noweb yes
<<imports_for_sources>>
<<oauth_session_creation>>
<<serve_index_html>>
<<login_route>>	
<<callback_google_api>>
<<logout_route>>
<<logged_in>>
<<add_user>>
<<add_role>>
<<show_users>>
<<show_roles>>
<<delete_user>>
<<delete_role>>
<<update_user>>
<<update_profile>>
<<lds_get>>
<<lds_post>>
<<lds_put>>
<<lds_delete>>
#+END_SRC
   


   
